/*数独求解源程序*/

#include<stdio.h>
#include<stdlib.h>
#include<conio.h>
#include<time.h>

/*输入函数，输入数独，使得只能输入0~9的数，0表示待填数*/
void shuru(char a[10][10][10]);

/*数独合法检测，若同一行、同一列、同一个九宫格里出现两个同样的数，则不合法。合法返回1，不合法返回0。*/
int hefa(char a[10][10][10]);

/*输出函数，输出数独，b参数表示a的第一维。*/
void shuchu(char a[10][10][10],int b);

/*判断求解后的数独是否正确，若数独里还有0，说明不正解返回0，否则正解返回1。*/
int zhengjie(char a[10][10][10]);

/*基本运算函数，根据每一行每一列每个九宫格只能填一个1~9的数来填数。*/
void JByunsuan(char a[10][10][10]);

/*枚举函数，当基本运算不能全部填完所有数时，用枚举方法找出所有正确解。*/
int meiju(char a[10][10][10]);

/*判断数独是否正解的第二种方法，如果从1~9所有的数都不能填入空格，说明正解返回1，否则返回0。*/
int ZJ2(char a[10][10][10]);

/*调试数据2*/
void TSshuju2(char a[10][10][10]);

/*调试数据1*/
void TSshuju1(char a[10][10][10]);

/*静态变量，用于判断数独正解的个数。*/
int M;

int T;

int K,K1;

/*说明：如果不喜欢的话，可以将相应的运算过程的输出删除*/

/*运算过程语句解释如下：*/

/*                     “%d行%d列：%d” 表示运算时计算机在数独中填的数*/

/*                     “**********%d行%d列：%d” 表示计算机枚举时在数独中填的数，可能填后会无解*/

/*                     “下一层” 表示进入下一个递归函数，即下一层枚举*/

/*                     “返回上一层” 表示返回上一层函数*/

/*                     “error” 表示该枚举方案错误*/

/*                     “right” 表示该枚举方案正确*/

/*                     “b[%d]=%d” 表示该层函数枚举的数量编号（前%d）及这些数所在的列序号（后%d）*/

/*这些运算过程输出语句更多的是为了测试方便，不过也能体现运算过程*/

/*bug：程序运行的时候不要输入...输入数独的时候也不要多输数...*/



int main()
{
	printf("欢迎进入数独求解程序！\n");

	char dbug;

	/*是否退出程序的循环*/
	do{
		/*定义数独，第二三维表示数独的行和列，第一维0表示原数独，1~9表示数字“1”~“9”在原数独中的可填情况。*/
		char a[10][10][10];

		/*输入*/
		shuru(a);

		M=0;

		T=clock();

		K=K1=0;

		int t=clock();

		/*调试数据*/
	//	TSshuju2(a);            

		/*测试用的输出模块*/
	//	shuchu(a,0);      

		printf("\n数独解的情况如下：\n");

		/*检验数独的合法性*/
		if(hefa(a))
		{
			/*先进行基本运算*/
			JByunsuan(a);

		//	shuchu(a,0);

			/*对于基本运算不能解决的数独，再用枚举法*/
			if(!zhengjie(a))
				if(!ZJ2(a))

					/*枚举*/
					meiju(a);
				else
					printf("\n该数独有0个解。\n");

			else
			{
				M++;
				printf("\n第%d个解：\n",M);
				shuchu(a,0);
			}

			/*枚举后输出解的个数*/
			printf("\n该数独共有%d解。\n",M);
		}
		else
			printf("\n该数独有0个解。\n");
	
		printf("\n共用时%dms\n",clock()-t);

		printf("\n运算结束，退出请按q，按c继续:");

		while((dbug=getch())!='q'&&dbug!='c');
     
	}while(dbug!='q');

	return 0;
}



void shuru(char a[10][10][10])
{
	/*输入数独*/
	printf("\n请输入待解数独，有数的地方写数字，待填的地方写‘0’。\n");

	int i,j;
	char c;

	for(i=1;i<=9;i++)
	{
		/*第一行的边框设计*/
		if(i==1)
			printf("\n|-------|-------|-------|\n");

		for(j=1;j<=9;j++)
		{
			c=getch();

			/*如果输入退格，可以重输*/
			if(c!='\b')
			{
			
				/*输入控制，使得只能输入0~9*/
				if((c=='0')||((c>='1')&&(c<='9')))
				{
					if(j==1)
						printf("| ");

					a[0][i][j]=c;

					printf("%c ",a[0][i][j]);

					if(j%3==0)
						printf("| ");

					if(j==9)
						printf("\n");
				}

				/*如果用户输入的数字不是0~9则重新输入*/
				else
				{
					j--;

					continue;
				}

			}
			else
			{
				if(j!=1)
				{
					if(j==4||j==7||j==2)
						printf("\b\b\b\b    \b\b\b\b");

					else
						printf("\b\b  \b\b");

					j--;
					j--;

				//	printf("\n%d\n",j);

					continue;
				}
				else
				{
					j--;

					continue;
				}
			}
		}

		if(i%3==0)
			printf("|-------|-------|-------|\n");
	}
}



int hefa(char a[10][10][10])
{
	/*验证输入数独的合法性*/
	int i,j,k,num=0;
	char z;

	/*从数字1~9依次检验*/
	for(z='1';z<='9';z++)
	{
		/*行循环*/
		for(i=1;i<=9;i++)
		{
			/*检验列中是否有该数字，若有，num加1*/
			for(j=1;j<=9;j++)
				if(a[0][i][j]==z)
					num++;

			/*如果该数的个数大于1，数独不合法，返回0*/
			if(num>1)
				return 0;

			/*列循环结束，num归零*/
			num=0;
		}

		/*同样，先列循环，再依次检验该行中是否有数据违法*/
		for(i=1;i<=9;i++)
		{
			for(j=1;j<=9;j++)
				if(a[0][j][i]==z)
					num++;

			if(num>1)
				return 0;

			num=0;
		}

		/*检验九个九宫格中是否有数据违法*/
		for(k=1;k<=3;k++)
		{ 
			/*九宫格的行列循环，九宫格看成一个整体，即3*3循环*/
			for(j=(k-1)*3+1;j<=k*3;j++)
				for(i=(k-1)*3+1;i<=k*3;i++)
					if(a[0][j][i]==z)
						num++;

			if(num>1)
				return 0;

			num=0;
		}
	}

	/*若经过了上述三种检验未发现数据合法，则数独合法*/
	return 1;
}



void shuchu(char a[10][10][10],int b)
{
	/*输出数独，与输入类似*/
	int i,j;

	printf("\n");

	for(i=1;i<=9;i++)
	{
	    if(i==1)
			printf("|-------|-------|-------|\n");

		for(j=1;j<=9;j++)
		{
		    if(j==1)
				printf("| ");

		    printf("%c ",a[b][i][j]);
		    if(j%3==0)
				printf("| ");

		    if(j==9)
				printf("\n");
	    }
	    if(i%3==0)
			printf("|-------|-------|-------|\n");
    }
}



int zhengjie(char a[10][10][10])
{
	/*判断数独是否正解，与判断数独是否合法类似*/
	int i,j;

	/*行列循环，依次检验数独中是否有0，有说明数独未解完，返回0，否则正解，返回1*/
	for(i=1;i<=9;i++)
		for(j=1;j<=9;j++)
			if(a[0][i][j]=='0')
				return 0;

	return 1;
}



int ZJ2(char a[10][10][10])
{
	/*第二种检验数独是否正解的方法，依次检验各数字1~9在原数独中的可填情况*/
	/*若全部为1说明全部不可填，即数独完解，返回1，否则说明数独还未解完，返回0*/
	int i1,j1,k1;
	for(i1=1;i1<=9;i1++)
		for(j1=1;j1<=9;j1++)
			for(k1=1;k1<=9;k1++)
				if(a[i1][j1][k1]=='0')
					return 0;	

	return 1;
}



void JByunsuan(char a[10][10][10])
{
	/*基本运算，根据每一行每一列每个九宫格只能填一个1~9的数来填数。*/
	int i,j,k=0;
	char z;

	/*将1~9的可填性初始化为0，即全可填*/
	for(i=1;i<=9;i++)
		for(j=1;j<=9;j++)
			for(k=1;k<=9;k++)
				a[i][j][k]='0';

	/*将k重新定位0*/
	k=0;

	/*从数字1~9循环*/
	for(z='1';z<='9';z++)
	{
		int word=0,num=0;

		/*将char的z变成int的k*/
		k++;

		/*先行循环，再列循环*/
		for(i=1;i<=9;i++)
			for(j=1;j<=9;j++)
			{
				/*如果原数独中这个格有数，则z的可填性为不可填*/
				if(a[0][i][j]!='0')
					a[k][i][j]='1';

				/*如果原数独中这个格填的刚好是z，则这个数的行，列，九宫格所有的z的可填性均为不可填*/
				if(a[0][i][j]==z)
				{
					int m;

					/*行、列*/
					for(m=1;m<=9;m++)
						a[k][i][m]=a[k][m][j]='1';

					int x,y;

					/*九宫格*/
					for(x=(i-1)/3*3+1;x<=(i-1)/3*3+3;x++)
						for(y=(j-1)/3*3+1;y<=(j-1)/3*3+3;y++)
							a[k][x][y]='1';
				}
			}

		/*测试输出*/
	//	printf("\n%d",k);
	//	shuchu(a,k); 

		/*行、列循环，如果有一行或一列z的可填性只有一个空可填，则这个空应填z*/
		for(i=1;i<=9;i++)
		{
			/*扫描该行的z的可填性*/
			for(j=1;j<=9;j++)
				if(a[k][i][j]=='0')
					num++;

			/*如果可填性只有一个空，扫描找到这个空并赋值为z*/
			if(num==1)
			{
				for(j=1;j<=9;j++)
					if(a[k][i][j]=='0')
					{
						a[0][i][j]=z;

					//	printf("%d行%d列：%c\n",i,j,z);
					}

				/*将word的值更为1，表示数独有变动*/
				word=1;

				/*有一个值改变时及时跳出*/
				/*绝对不能少它，否则会一列中多个0会因为在不同的行中只有它一个而被误赋值*/
				/*同样必须全部跳出直到下一个continue处，因为原数独改变了，其1~9的可填性也改变了，需要重新更改*/
				/*这个地方很容易错，而且很不容易发现，又花了很多时间*/
				break;
			}
			num=0;

			/*同理改为列*/
			for(j=1;j<=9;j++)
				if(a[k][j][i]=='0')
					num++;
			if(num==1)
			{
				for(j=1;j<=9;j++)
					if(a[k][j][i]=='0')
					{
						a[0][j][i]=z;

					//	printf("%d行%d列：%c\n",i,j,z);
					}
				word=1;

				break;
			}

			num=0;
		}

		/*如果数独有变动，则将z、k归零，重新循环*/
		if(word==1)
		{
			z='0';
			k=0;

			continue;
		}
	}
}




int meiju(char a[10][10][10])
{
	if(((clock()-T)>=10000)&&(M==0)&&(K1==0))
	{
		printf("\n运算时间已经超过了10s，请检查输入的数据是否有误。\n");
		printf("有误，重来请按y\n无误，我想继续请按n: ");

		/*fflush()不能用,为什么？？？？bug*/
	//	system("pause");
		char cbug;
		while((cbug=getch())!='y'&&cbug!='n');
		if(cbug=='y')
		{
			K=1;
			K1=1;
			printf("\n");
			return 0;
		}
	//	system("pause");
		K1=1;
		printf("\n");
	}

	/*枚举函数，当基本运算不能全部填完所有数时，用枚举方法找出所有正确解。*/
	int i,j,k=0;
	char z;

	/*从1~9循环，实际上并没有循环，只是找出满足条件的最近的一个z*/
	for(z='1';z<='9';z++)
	{
		k++;

		/*行循环，实际上并没有循环，只是找出满足条件的最近的一行*/
		for(i=1;i<=9;i++)
		{
			/*定义b，将该行的可填性的列序号放在b中，可填性最大为9，故a[10]=0来控制循环结束*/
			int b[11]={0};
			int p;

			/*扫描该行，将该行的z可填性记录在b中*/
			for(j=1;j<=9;j++)

				/*该格为0说明可填*/
				if(a[k][i][j]=='0')

					/*扫描b[]，将列序号填在b中不为零的地方*/
					for(p=1;p<=9;p++)
						if(b[p]==0)
						{
							b[p]=j;

							/*跳出老忘记*/
							break;
						}

			/*检验该行是否有可填的空，若有，由于经过了基本运算，至少有两个，即b[1]=0或b[1]=b[2]=1*/
			if(b[1]!=0)
			{
				/*从该行的可填的数的第一个开始循环*/
				for(p=1;p<=10;p++)
				{
					/*如果未循环完即b[p]仍然表示可填的空*/
					if(b[p]!=0)
					{
						/*定义一个数独*/
						char c[10][10];

						int x1,x2;

						/*将枚举前的数独先存起来，在以后枚举失败时还原*/
						for(x1=1;x1<=9;x1++)
							for(x2=1;x2<=9;x2++)
								c[x1][x2]=a[0][x1][x2];

						/*将改个可填的空枚举为z*/
						a[0][i][b[p]]=z;

					//	for(int iK=1;iK<=10;iK++)
						//	if(b[iK]!=0)
							//	printf("b[%d]=%d ",iK,b[iK]);

					//	printf("\n");
					//	printf("**********%d行%d列：%d\n",i,b[p],k);

					//	shuchu(a,0);

					//	system("pause");

						/*再次基本运算*/
						JByunsuan(a);

						/*基本运算后判断原数独是否全部完成*/
				        if(zhengjie(a))
						{
						//	printf("right\n");

							/*正解得数量加1*/
							M++;

							printf("\n第%d个解：\n",M);

							/*如果原数独全部完成，输出*/
							shuchu(a,0);

						//	printf("\n按任意键继续进行求解运算\n");
						//	system("pause");

							/*求得一正解后，将原数独还原，继续下一个可填性循环*/
							for(x1=1;x1<=9;x1++)
									for(x2=1;x2<=9;x2++)
										a[0][x1][x2]=c[x1][x2];
						}
						else
							/*如果数独的空未填完而所有的1~9数都不可填，说明该枚举错误*/
							if(ZJ2(a))
							{
							//	printf("error\n");

								/*重新还原原数独，继续循环*/
								for(x1=1;x1<=9;x1++)
									for(x2=1;x2<=9;x2++)
										a[0][x1][x2]=c[x1][x2];
							//	shuchu(a,0);
							}
							/*如果数独的空未填完而还有数可以填，则递归之...*/
							/*这个递归花了好长时间才写出来,总是错*/
							else
							{

							//	printf("下一层\n");

								meiju(a);

								if(K==1)
									return 0;

								/*枚举返回后，原数独还原，继续p循环*/
								for(x1=1;x1<=9;x1++)
									for(x2=1;x2<=9;x2++)
										a[0][x1][x2]=c[x1][x2];
							
							}
					}
					/*如果b[p]=0，说明该数该行可填的可能已经全部循环完*/
					/*而如果该行有该数可填的空格，则该数必在该行的这几个空格中*/
					/*如果循环完，说明所有的可能性已经全部循环完了，故返回*/
					else
					{

					//	printf("返回上一层\n");

						return 0;
					}
				}
			//	return 0;
			}
		}
	}	
}



void TSshuju1(char a[10][10][10])
{
	/*调试数据1,有且只有一解*/
	a[0][1][1]='0';
	a[0][1][2]='0';
	a[0][1][3]='1';
	a[0][1][4]='0';
	a[0][1][5]='0';
	a[0][1][6]='9';
	a[0][1][7]='0';
	a[0][1][8]='0';
	a[0][1][9]='6';
	a[0][2][1]='0';
	a[0][2][2]='0';
	a[0][2][3]='5';
	a[0][2][4]='4';
	a[0][2][5]='8';
	a[0][2][6]='0';
	a[0][2][7]='0';
	a[0][2][8]='9';
	a[0][2][9]='3';
	a[0][3][1]='0';
	a[0][3][2]='0';
	a[0][3][3]='0';
	a[0][3][4]='0';
	a[0][3][5]='0';
	a[0][3][6]='0';
	a[0][3][7]='0';
	a[0][3][8]='8';
	a[0][3][9]='0';
	a[0][4][1]='0';
	a[0][4][2]='3';
	a[0][4][3]='0';
	a[0][4][4]='0';
	a[0][4][5]='0';
	a[0][4][6]='5';
	a[0][4][7]='4';
	a[0][4][8]='0';
	a[0][4][9]='1';
	a[0][5][1]='0';
	a[0][5][2]='7';
	a[0][5][3]='0';
	a[0][5][4]='0';
	a[0][5][5]='0';
	a[0][5][6]='0';
	a[0][5][7]='0';
	a[0][5][8]='3';
	a[0][5][9]='0';
	a[0][6][1]='1';
	a[0][6][2]='0';
	a[0][6][3]='6';
	a[0][6][4]='3';
	a[0][6][5]='0';
	a[0][6][6]='0';
	a[0][6][7]='0';
	a[0][6][8]='5';
	a[0][6][9]='0';
	a[0][7][1]='0';
	a[0][7][2]='6';
	a[0][7][3]='0';
	a[0][7][4]='0';
	a[0][7][5]='0';
	a[0][7][6]='0';
	a[0][7][7]='0';
	a[0][7][8]='0';
	a[0][7][9]='0';
	a[0][8][1]='0';
	a[0][8][2]='5';
	a[0][8][3]='0';
	a[0][8][4]='0';
	a[0][8][5]='9';
	a[0][8][6]='3';
	a[0][8][7]='2';
	a[0][8][8]='0';
	a[0][8][9]='0';
	a[0][9][1]='3';
	a[0][9][2]='0';	
	a[0][9][3]='0';
	a[0][9][4]='5';
	a[0][9][5]='0';
	a[0][9][6]='0';
	a[0][9][7]='6';
	a[0][9][8]='0';
	a[0][9][9]='0';
}



void TSshuju2(char a[10][10][10])
{
	/*调试数据2,有21个不同解*/
	a[0][1][1]='0';
	a[0][1][2]='0';
	a[0][1][3]='1';
	a[0][1][4]='0';
	a[0][1][5]='3';
	a[0][1][6]='9';
	a[0][1][7]='5';
	a[0][1][8]='2';
	a[0][1][9]='6';
	a[0][2][1]='0';
	a[0][2][2]='0';
	a[0][2][3]='5';
	a[0][2][4]='0';
	a[0][2][5]='8';
	a[0][2][6]='0';
	a[0][2][7]='0';
	a[0][2][8]='9';
	a[0][2][9]='3';
	a[0][3][1]='0';
	a[0][3][2]='0';
	a[0][3][3]='3';
	a[0][3][4]='0';
	a[0][3][5]='5';
	a[0][3][6]='0';
	a[0][3][7]='0';
	a[0][3][8]='8';
	a[0][3][9]='0';
	a[0][4][1]='0';
	a[0][4][2]='3';
	a[0][4][3]='0';
	a[0][4][4]='0';
	a[0][4][5]='0';
	a[0][4][6]='5';
	a[0][4][7]='4';
	a[0][4][8]='6';
	a[0][4][9]='1';
	a[0][5][1]='5';
	a[0][5][2]='7';
	a[0][5][3]='0';
	a[0][5][4]='0';
	a[0][5][5]='6';
	a[0][5][6]='0';
	a[0][5][7]='0';
	a[0][5][8]='3';
	a[0][5][9]='0';
	a[0][6][1]='1';
	a[0][6][2]='0';
	a[0][6][3]='6';
	a[0][6][4]='3';
	a[0][6][5]='0';
	a[0][6][6]='0';
	a[0][6][7]='0';
	a[0][6][8]='5';
	a[0][6][9]='0';
	a[0][7][1]='0';
	a[0][7][2]='6';
	a[0][7][3]='0';
	a[0][7][4]='0';
	a[0][7][5]='1';
	a[0][7][6]='0';
	a[0][7][7]='3';
	a[0][7][8]='0';
	a[0][7][9]='5';
	a[0][8][1]='0';
	a[0][8][2]='5';
	a[0][8][3]='0';
	a[0][8][4]='6';
	a[0][8][5]='9';
	a[0][8][6]='3';
	a[0][8][7]='2';
	a[0][8][8]='1';
	a[0][8][9]='0';
	a[0][9][1]='3';
	a[0][9][2]='1';	
	a[0][9][3]='0';
	a[0][9][4]='5';
	a[0][9][5]='0';
	a[0][9][6]='0';
	a[0][9][7]='6';
	a[0][9][8]='0';
	a[0][9][9]='0';
}